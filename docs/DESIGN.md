# Design

The `wc3v` project aims to be able to get useful and impactful information
out of a WC3 replay file.  Because the `w3g` file format only contains
information about player inputs - the engine must keep track of uncertain
game events and actions by simulating them.

### Why has this been built?

WC3 matches are packed with action and information and the only way to view most of these matches is by loading the WC3 game application.  This is a huge burden for many fans of the game and can often make it so lots of exciting matches don't ever get watched unless they are cast live.

For the love of WC3, DotA, and to push technical understanding and limits, here is a system to pull out this rich information about a match into a quick 'birds eye view'.

The long term goal of WC3V is to be a community hub to find out everything about a match, player, or map in the land of WC3.


## WC3 Replay file layout

A replay file contains a timestamped series of actions performed by the players in the match.  Each action represents a unique command that a player can perform in the game and includes commands auto-generated by WC3 itself.

The actions are stored in time linearly and must be processed (as best as possible ) deterministically as the game itself does.

There is some information stored in replay files such as metadata about the match - but many important things are left out to be calculated by the game itself. Even critically important information such as which of the map starting positions a player actually started at.  The WC3V engine must determine some of these things as best it can.

Existing WC3 replay parsing systems track only basic information about a match such as which units were produced, hero types and levels, and statistics such as APM (actions per minute).

To overcome these challenges and extract rich information from a replay the WC3V engine does something none other has tried - simulating enough of WC3 such that you as a viewer understand what went down in a match without ever having to load the WC3 game application.

## Unit Tracking

The replay file tracks units with three basic concepts:

* `itemId` - either a unique string or a 4 entry list 
* `objectId1` and `objectId2` - numeric ids, unique to each unit
* `itemId1` and `itemId2` - numeric ids, list of 4 integers

There is a loose association of a units `itemId1-2` pair to its `object1-2` pair.  The game has an internal lookup table that it generated and easily knows all details about a unit based on either one of these unique properties.

But the consumers of replays get this information from different actions - we must use knowledge of the game, simulation, and tedious book keeping to maintain links between these data pairs.

### Player actions required to make more units

Because WC3 requires the player to actually perform actions in order for more units to "spawn" into the world - it's easy for us at this point to associate things when a user selects that unit.

As a player begins a (normal) match they will select their existing town hall and produce a new unit.  We track this new unit as an "unregistered" unit, up until it has spawned and since been selected.

## Gameplay Breakdown

In every WC3 match each race starts out with a group of workers (UD starts with 3, rest 5) + a town hall building.

We assume these units to exist when we define our player instances - any 'normal' game player will eventually select and interact with these units to start their base building.

### Selecting units 

When a player issues a command to `Change Selection` of the units the engine is told which `itemId` the player selected and a list of `itemId1` and `itemId2` keys for each selected unit. This `Change Selection` command is what happens either when you click on a unit - like a worker or a town hall; or when you tab-select between groups of units.

The `Select Subgroup` action gives us the `objectId1` and `objectId2` pair for the unit who is first in the group (and shown on your game UI).  The action is either a `select` or `deselect` tracked by the engine via the `SubGroup` class.

### Registering units

A unit becomes "registered" when they are both in a selection group and also the focus of a `Select Subgroup` action.  WC3 has an in-game concept of the "selected" unit in any sized group which is where the replay file gives an opportunity to connect the `itemId1-2` and `objectId1-2` pairs.

Unit metadata is mapped to known `itemId` values - giving us the ability to simulate different actions and in-game results.

### Known Object IDs

One property of a WC3 replay is that units with equal `objectId1-2` field were spawned at the start of game.  We can use this information to further enrich our parser choices.

The game tracks units with incrementing counters for ID's.  Once we identify the `itemId` of a worker, we know the rest of the worker ID's are within `N` total positions of this unit, because the game spawns them in sequentially.

Because of known game mechanisms like this, we are able to associate "known object IDs" for the 'worker' and 'town hall' groups.

These known object IDs can become useful later and are helpful for determining what an "unregistered" unit really is.

### Skills and Abilities

The WC3 engine tracks abilities of different categories based on how they function in-game.

For example: a hero skill that summons a unit when cast is an `Ability with no target`.

The types of abilities are:

* UseAbilityNoTarget
* UseAbilityWithTarget
* UseAbilityWithTargetAndObjectId
* UseAbilityTwoTargets

and a notable mention for another active command:

* GiveOrDropItem

#### Skill levels

The replay contains an action for when a hero skill is learned, allowing us to keep track of which skills a hero has taken and the level of the given skill.  

This is also a good way to infer hero level - but will not be done at the exact time a hero leveled up. Instead we are able to track the exact time and position when a unit selected their newly leveled skill.

### Player Position

WC3 uses a random seed to determine game outcomes such as where the player 'starting positions' should be on a given map.  This game seed is not currently understood.

The engine can be told to read the map `JASS` file and determine the possible list of starting
locations, and then 'predict' where the player started based on their known movements. Currently this is done manually - but for future proofing the wc3v engine should learn more about map + scripting data.

In almost 99% of real game scenarios we will be able to guess correctly based on the assumption that a player will build at least their buildings near their starting position, as well as being able to rule out positions already set by other players.

### Backfilling 

We previously mentioned the `wc3v` map parser sometimes handles units in an unregistered state. The actions units or buildings perform while still unregistered can be important to determining the state of the game.

The backfill is performed by simulating the actions that we've stored in a compacted format alongside the gametime at which they occurred.  Simulating the events allows for unit actions to be canceled or detected, in the same ways registered units have.

### Backfilling examples

One common example can be seen in the test replay `test-backfill.wc3g`:

The scenario is that a newly spawned `Hero (DK)` is moving around the map, then adds the game-spawned initial `Ghoul` to the selection group.  This `Ghoul` has yet to be selected directly - meaning we have not registered it yet.  The `w3cv` engine stores the action data it gets by associating it to the only known data we've gotten so far which is the `itemId1 / itemId2` pair.

After a couple of movement actions to and from a creep camp, the player eventually selects the `Ghoul` directly and sends them back to base.  At this point the `wc3v` parser recognizes that we've stored some `backfill` data for this `itemId1 / itemId2` pair in our action selections and performs a backfill of the data.

## Quirky stuff about WC3 Replays

Wc3 is an old and glorious game and therefore the replay files can contain some 'funny' things...

A number of tricks have been applied based on in-game knowledge, patterns in replay files, and
some educated guessing in order to make sense of some of the trickier parts of the replays.

One known issue with replay files is that actions can sometimes be duplicated - this occurs
in very laggy matches often - a result of this can be anything from a meaningless move command
up to a hero buying an item twice.  In game knowledge of shops and shop cooldowns help prevent
this item duplication - which can lead to other parser bugs due to our deterministic nature.

Destroying summoned units can often go wrong - players don't usually interact with both of their
summons directly, or can have multiple groups of them out at once.  We take a unit 'snapshot'
when a summon is created and reference it later one when a `PlayerActions.destroyUnit` call
can't find a registered unit to destroy.  The snapshot lets us filter out units whose `spawnTime`
don't match the potential `spawnTime` of our summon - simple way of narrowing down our choices
that often leads to the correct result.

The replay actions generated by the game have some quirky patterns to them - a notable usage
of this is the "same block" flag used when changing / selecting selection groups.  Because
the "same block" changes are consistently generated by the game under certain in game conditions,
we can filter out units we might have been tracking for too long (like dead ones).

Another fun trick is applied when figuring out moving of items - the game for whatever reason
gives items a target X,Y coordinate, and it turns out that coordinates with a non-zero decimal 
portion are bought from the shop! neat.

## Replay parsing uncertainty tracking

The wc3v exports a percentage confidence marked as `parseConfidence` which tracks how many times the `wc3v` engine encountered something it wasn't confident about.  These situations can occur for lots of reasons:  from tiny or minor actions that likely have no effect or have yet to be implemented, up to major confidence breakers where the engine couldn't find things it needed.

Viewers (and developers) can consider this mechanism as a way to handle ensuring _some_ result is generated from map replay files, without throwing fatal errors, and indicates when the representation of the game might be a little off.
